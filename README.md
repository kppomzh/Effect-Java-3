# Effect-Java-3
1. 考虑使⽤静态⼯⼚⽅法替代构造⽅法
⼀个类允许客户端获取其实例的传统⽅式是提供⼀个公共构造⽅法。 其实还有另⼀种技术应该成为每个程序员
⼯具箱的⼀部分。 ⼀个类可以提供⼀个公共静态⼯⼚⽅法，它只是⼀个返回类实例的静态⽅法。 下⾯是⼀个
Boolean 简单的例⼦（boolean 基本类型的包装类）。 此⽅法将 boolean 基本类型转换为 Boolean 对象引
⽤︓
public static Boolean valueOf(boolean b) {
 return b ? Boolean.TRUE : Boolean.FALSE;
}
注意，静态⼯⼚⽅法与设计模式中的⼯⼚⽅法模式不同[Gamma95]。本条⽬中描述的静态⼯⼚⽅法在设计模式
中没有直接的等价。
类可以为其客户端提供静态⼯⼚⽅法，⽽不是公共构造⽅法。提供静态⼯⼚⽅法⽽不是公共构造⽅法有优点也
有缺点。
静态⼯⼚⽅法的⼀个优点是，与构造⽅法不同，它们是有名字的。 如果构造⽅法的参数本⾝并不描述被返回的
对象，则具有精⼼选择名称的静态⼯⼚更易于使⽤，并且⽣成的客户端代码更易于阅读。 例如，返回⼀个可能
为素数的 BigInteger 的构造⽅法 BigInteger(int，int，Random) 可以更好地表⽰为名为
BigInteger.probablePrime 的静态⼯⼚⽅法。 （这个⽅法是在 Java 1.4 中添加的。）
⼀个类只能有⼀个给定签名的构造⽅法。 程序员知道通过提供两个构造⽅法来解决这个限制，这两个构造⽅法
的参数列表只有它们的参数类型的顺序不同。 这是⼀个⾮常糟糕的主意。 这样的 API ⽤户将永远不会记得哪个
构造⽅法是哪个，最终会错误地调⽤。 阅读使⽤这些构造⽅法的代码的⼈只有在参考类⽂档的情况下才知道代
码的作⽤。
因为他们有名字，所以静态⼯⼚⽅法不会受到上⾯讨论中的限制。在类中似乎需要具有相同签名的多个构造⽅
法的情况下，⽤静态⼯⼚⽅法替换构造⽅法，并仔细选择名称来突出它们的差异。
静态⼯⼚⽅法的第⼆个优点是，与构造⽅法不同，它们不需要每次调⽤时都创建⼀个新对象。 这允许不可变类
（详见第 17 条）使⽤预先构建的实例，或者在构造时缓存实例，并反复分配它们以避免创建不必要的重复对
象。Boolean.valueof(boolean) ⽅法说明了这种⽅法︓它从不创建对象。这种技术类似于 Flyweight 模式
[Gamma95]。如果经常请求等价对象，那么它可以极⼤地提⾼性能，特别是在创建它们的代价⾮常昂贵的情况
下。
静态⼯⼚⽅法重复调⽤返回相同实例这个特点可以让类在任何时候都能对实例保持严格的控制。这样做的类被
称为实例控制类（ instance-controlled）。有很多理由⾜以让我们去我们编写实例控制类。实例控制可以保证
⼀个类是单例 的（详见第 3 条） 或不可实例化的 （详见第 4 条）。同时,它允许⼀个不可变的值类 （详见第
17 条） 保证不存在两个相等但不相同的实例，也就是说当且仅当 a == b 时才有 a.equals(b)。这是
Flyweight模式的基础[Gamma95]。Enum 类型 （详见第 34 条）可以做到这点。
静态⼯⼚⽅法的第三个优点是，与构造⽅法不同，它们可以返回其返回类型的任何⼦类型的对象。 这为你在选
择返回对象的类时提供了很⼤的灵活性。
这种灵活性的⼀个应⽤是 API 可以返回对象⽽不需要公开它的类。 以这种⽅式隐藏实现类会使 API ⾮常紧凑。
这种技术适⽤于基于接⼝的框架（详见第 20 条），其中接⼝为静态⼯⼚⽅法提供⾃然返回类型。
all.md 2023/4/30
2 / 248
在 Java 8 之前，接⼝不能有静态⽅法。根据约定，⼀个名为 Type 的接⼝的静态⼯⼚⽅法被放⼊⼀个不可实例
化的伙伴类（companion class）（详见第 4 条）Types 类中。例如，Java 集合框架有 45 个接⼝的实⽤⼯具实
现，提供不可修改的集合、同步集合等等。⼏乎所有这些实现都是通过静态⼯⼚⽅法在⼀个不可实例化的类
(java .util. collections) 中返回的。返回对象的类都隐藏的。
Collections 框架 API 的规模要⽐它之前返回的 45 个单独的公共类要⼩得多，每个类在集合框架中都有⼀个
便利的实现。不仅是 API 的⼤部分减少了，还包括概念上的权重︓程序员要想使⽤ API必须掌握的概念的数量
和难度。程序员知道返回的对象恰好有其接⼝指定的 API，因此不需要为实现类读阅读额外的类⽂档。此外，
使⽤这种静态⼯⼚⽅法需要客户端通过接⼝⽽不是实现类来引⽤返回的对象，这通常是良好的实践（详见第 64
条）。
从 Java 8 开始，接⼝不能包含静态⽅法的限制被取消了，所以通常没有理由为接⼝提供⼀个不可实例化的伴随
类。 很多公开的静态成员应该放在这个接⼝本⾝。 但是，请注意，将这些静态⽅法的⼤部分实现代码放在单独
的包私有类中仍然是必要的。 这是因为 Java 8 要求所有接⼝的静态成员都是公共的。 Java 9 允许私有静态⽅
法，但静态字段和静态成员类仍然需要公开。
静态⼯⼚的第四个优点是返回对象的类可以根据输⼊参数的不同⽽不同。 声明的返回类型的任何⼦类都是允许
的。 返回对象的类也可以随每次发布⽽不同。
EnumSet 类（详见第 36 条）没有公共构造⽅法，只有静态⼯⼚。 在 OpenJDK 实现中，它们根据底层枚举类
型的⼤⼩返回两个⼦类中的⼀个的实例︓⼤多数枚举类型具有 64 个或更少的元素，静态⼯⼚将返回⼀个
RegularEnumSet 实例， 底层是long 类型︔如果枚举类型具有六⼗五个或更多元素，则⼯⼚将返回⼀个
JumboEnumSet 实例，底层是long 类型的数组。
这两个实现类的存在对于客户端⽽⾔是不可见的。 如果 RegularEnumSet 对于⼩的枚举类型不再具有性能优
势，则可以在未来版本中将其淘汰，且不会产⽣任何不良影响。 同样，如果可以证明添加 EnumSet 的更多的
实现可以提⾼性能，那么在未来的版本可能就会这样做。 客户既不知道也不关⼼他们从⼯⼚返回的对象的类别;
他们只需要知道它是 EnumSet 的⼦类。
静态⼯⼚的第五个优点是，在编写包含该⽅法的类时，返回的对象的类不需要存在。 这种灵活的静态⼯⼚⽅法
构成了服务提供者框架的基础，⽐如 Java 数据库连接 API（JDBC）。服务提供者框架是提供者实现服务的系
统，并且系统使得实现对客户端可⽤，从⽽将客户端从实现中分离出来。
服务提供者框架中有三个基本组︓服务接⼝，它表⽰实现︔提供者注册 API，提供者⽤来注册实现︔以及服务
访问 API，客户端使⽤该 API 获取服务的实例。服务访问 API 允许客户指定选择实现的标准。在缺少这样的标
准的情况下，API 返回⼀个默认实现的实例，或者允许客户通过所有可⽤的实现进⾏遍历。服务访问 API 是灵
活的静态⼯⼚，它构成了服务提供者框架的基础。
服务提供者框架的⼀个可选的第四个组件是⼀个服务提供者接⼝，它描述了⼀个⽣成服务接⼝实例的⼯⼚对
象。在没有服务提供者接⼝的情况下，必须对实现进⾏反射实例化（详见第 65 条）。在 JDBC 的情况下，
Connection 扮演服务接⼝的⼀部分，DriverManager.registerDriver 提供程序注册 API、
DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接⼝。
服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回⽐提供者提供的更丰富的服务接⼝。
这是桥接模式[Gamma95]。 依赖注⼊框架（详见第 5 条）可以被看作是强⼤的服务提供者。 从 Java 6 开始，
平台包含⼀个通⽤的服务提供者框架 java.util.ServiceLoader，所以你不需要，⼀般也不应该⾃⼰编写
（详见第 59 条）。 JDBC 不使⽤ ServiceLoader，因为前者早于后者。
只提供静态⼯⼚⽅法的主要限制是，没有公共或受保护构造⽅法的类不能被⼦类化。 例如，要想将
Collections 框架中任何遍历的实现类进⾏⼦类化，是不可能的。但是这样也会因祸得福，因为它⿎励程序员
all.md 2023/4/30
3 / 248
使⽤组合（composition）⽽不是继承（详见第 18 条），并且是不可变类型锁需要的（详见第 17 条）。
静态⼯⼚⽅法的第⼆个缺点是，程序员很难找到它们。 它们不像构造⽅法那样在 API ⽂档中明确的标注出来。
因此，对于提供了静态⽅法⽽不是构造器的类来说，想要查明如何实例化⼀个类是⼗分困难的。Javadoc ⼯具
可能有⼀天会注意到静态⼯⼚⽅法。与此同时，通过关注类或者接⼝的⽂档中静态⽅法，并且遵守标准的命名
习惯，也可以弥补这⼀劣势。下⾯是⼀些静态⼯⼚⽅法的常⽤名称。以下清单这是列出了其中的⼀⼩部分︓
from —— 类型转换⽅法，它接受单个参数并返回此类型的相应实例，例如︓Date d =
Date.from(instant);
of —— 聚合⽅法，接受多个参数并返回该类型的实例，并把他们合并在⼀起，例如︓Set<Rank>
faceCards = EnumSet.of(JACK, QUEEN, KING);
valueOf —— from 和 to 更为详细的替代 ⽅式，例如︓BigInteger prime =
BigInteger.valueOf(Integer.MAX_VALUE);
instance 或 getinstance —— 返回⼀个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，
例如︓StackWalker luke = StackWalker.getInstance(options);
create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该⽅法保证每次调⽤返回⼀个新
的实例，例如︓Object newArray = Array.newInstance(classObject, arrayLen);
getType —— 与 getInstance 类似，但是在⼯⼚⽅法处于不同的类中的时候使⽤。getType 中的 Type 是
⼯⼚⽅法返回的对象类型，例如︓FileStore fs = Files.getFileStore(path);
newType —— 与 newInstance 类似，但是在⼯⼚⽅法处于不同的类中的时候使⽤。newType中的 Type
是⼯⼚⽅法返回的对象类型，例如︓BufferedReader br = Files.newBufferedReader(path);
type —— getType 和 newType 简洁的替代⽅式，例如︓List<Complaint> litany =
Collections.list(legacyLitany);
总之，静态⼯⼚⽅法和公共构造⽅法都有它们的⽤途，并且了解它们的相对优点是值得的。通常，静态⼯⼚更
可取，因此避免在没有考虑静态⼯⼚的情况下直接选择使⽤公共构造⽅法。
